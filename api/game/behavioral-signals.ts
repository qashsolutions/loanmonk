// ============================================================
// POST /api/game/behavioral-signals
// Receives raw behavioral data from Supply Run game
// Computes behavioral OCEAN scores and stores everything
// ============================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { getServerSupabase } from '../../lib/utils/supabase.js';
import { computeAllBehavioralScores, computeBartScore } from '../../lib/scoring/behavioral.js';
import type { BehavioralSignalsRequest, BehavioralSignals } from '../../lib/types/index.js';

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method === 'OPTIONS') return res.status(200).end();
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });

  try {
    const { session_id, signals } = req.body as BehavioralSignalsRequest;

    if (!session_id || !signals) {
      return res.status(400).json({ error: 'session_id and signals are required' });
    }

    const supabase = getServerSupabase();

    // Verify session
    const { data: session, error: sessionError } = await supabase
      .from('sessions')
      .select('id, status')
      .eq('id', session_id)
      .single();

    if (sessionError || !session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    if (session.status !== 'phase1_complete') {
      return res.status(400).json({ error: 'Phase 1 must be completed before submitting behavioral signals' });
    }

    // Construct full behavioral signals object for scoring
    const fullSignals: BehavioralSignals = {
      id: '', // Will be generated by DB
      session_id,
      game_seed: signals.game_seed,
      duration_ms: signals.duration_ms,
      tap_velocities: signals.tap_velocities || [],
      path_records: signals.path_records || [],
      banking_events: signals.banking_events || [],
      cargo_loads: signals.cargo_loads || [],
      loss_events: signals.loss_events || [],
      sharing_events: signals.sharing_events || [],
      exploration_tiles: signals.exploration_tiles || 0,
      total_tiles: signals.total_tiles || 0,
      crowd_time_ms: signals.crowd_time_ms || 0,
      quiet_time_ms: signals.quiet_time_ms || 0,
      multi_order_counts: signals.multi_order_counts || [],
      behavioral_scores: { O: 0, C: 0, E: 0, A: 0, N: 0 },
      bart_score: 0,
    };

    // Compute behavioral scores
    const behavioralScores = computeAllBehavioralScores(fullSignals);
    const bartScore = computeBartScore(fullSignals.cargo_loads);

    // Store in database
    const { data: storedSignal, error: insertError } = await supabase
      .from('behavioral_signals')
      .insert({
        session_id,
        game_seed: signals.game_seed,
        duration_ms: signals.duration_ms,
        tap_velocities: signals.tap_velocities,
        path_records: signals.path_records,
        banking_events: signals.banking_events,
        cargo_loads: signals.cargo_loads,
        loss_events: signals.loss_events,
        sharing_events: signals.sharing_events,
        exploration_tiles: signals.exploration_tiles,
        total_tiles: signals.total_tiles,
        crowd_time_ms: signals.crowd_time_ms,
        quiet_time_ms: signals.quiet_time_ms,
        multi_order_counts: signals.multi_order_counts,
        behavioral_scores: behavioralScores,
        bart_score: bartScore,
      })
      .select()
      .single();

    if (insertError || !storedSignal) {
      return res.status(500).json({ error: 'Failed to store behavioral signals', details: insertError?.message });
    }

    // Update session status
    await supabase
      .from('sessions')
      .update({
        status: 'phase2_complete',
        phase2_completed_at: new Date().toISOString(),
      })
      .eq('id', session_id);

    return res.status(200).json({
      signal_id: storedSignal.id,
      behavioral_scores: behavioralScores,
      bart_score: bartScore,
    });
  } catch (error) {
    const errMsg = error instanceof Error ? error.message : 'Unknown error';
    return res.status(500).json({ error: 'Internal server error', details: errMsg });
  }
}
